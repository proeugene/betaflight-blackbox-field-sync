"""Huffman decompression for MSP DATAFLASH_READ compressed responses.

Ported from:
  betaflight-configurator/src/js/huffman.js
  betaflight-configurator/src/js/default_huffman_tree.js

The tree is sorted by code length, then by code value.
huffmanLenIndex[n] = index of first entry with codeLen == n, or -1.
"""
from __future__ import annotations

from dataclasses import dataclass
from typing import Optional

HUFFMAN_EOF = -1


@dataclass(frozen=True)
class HuffmanEntry:
    value: int   # decoded byte value, or HUFFMAN_EOF (-1)
    code_len: int
    code: int


# fmt: off
# Ported verbatim from default_huffman_tree.js
# Each entry: (value, code_len, code)
_RAW_TREE: list[tuple[int, int, int]] = [
    (0x00, 2, 0x00), (0x01, 2, 0x01), (0x02, 3, 0x04), (0x03, 3, 0x05),
    (0x04, 3, 0x06), (0x50, 3, 0x07), (0x05, 4, 0x10), (0x06, 4, 0x11),
    (0x07, 4, 0x12), (0x08, 4, 0x13), (0x09, 4, 0x14), (0x0a, 4, 0x15),
    (0x0b, 4, 0x16), (0x0c, 4, 0x17), (0x0d, 4, 0x18), (0x0e, 4, 0x19),
    (0x0f, 4, 0x1a), (0x10, 4, 0x1b), (0x11, 4, 0x1c), (0x12, 4, 0x1d),
    (0x13, 4, 0x1e), (0x14, 4, 0x1f), (0x15, 5, 0x40), (0x16, 5, 0x41),
    (0x17, 5, 0x42), (0x18, 5, 0x43), (0x19, 5, 0x44), (0x1a, 5, 0x45),
    (0x1b, 5, 0x46), (0x1c, 5, 0x47), (0x1d, 5, 0x48), (0x1e, 5, 0x49),
    (0x1f, 5, 0x4a), (0x20, 5, 0x4b), (0x21, 5, 0x4c), (0x22, 5, 0x4d),
    (0x23, 5, 0x4e), (0x24, 5, 0x4f), (0x25, 5, 0x50), (0x26, 5, 0x51),
    (0x27, 5, 0x52), (0x28, 5, 0x53), (0x29, 5, 0x54), (0x2a, 5, 0x55),
    (0x2b, 5, 0x56), (0x2c, 5, 0x57), (0x2d, 5, 0x58), (0x2e, 5, 0x59),
    (0x2f, 5, 0x5a), (0x30, 5, 0x5b), (0x31, 5, 0x5c), (0x32, 5, 0x5d),
    (0x33, 5, 0x5e), (0x34, 5, 0x5f), (0x35, 6, 0xc0), (0x36, 6, 0xc1),
    (0x37, 6, 0xc2), (0x38, 6, 0xc3), (0x39, 6, 0xc4), (0x3a, 6, 0xc5),
    (0x3b, 6, 0xc6), (0x3c, 6, 0xc7), (0x3d, 6, 0xc8), (0x3e, 6, 0xc9),
    (0x3f, 6, 0xca), (0x40, 6, 0xcb), (0x41, 6, 0xcc), (0x42, 6, 0xcd),
    (0x43, 6, 0xce), (0x44, 6, 0xcf), (0x45, 6, 0xd0), (0x46, 6, 0xd1),
    (0x47, 6, 0xd2), (0x48, 6, 0xd3), (0x49, 6, 0xd4), (0x4a, 6, 0xd5),
    (0x4b, 6, 0xd6), (0x4c, 6, 0xd7), (0x4d, 6, 0xd8), (0x4e, 6, 0xd9),
    (0x4f, 6, 0xda), (0x51, 6, 0xdb), (0x52, 6, 0xdc), (0x53, 6, 0xdd),
    (0x54, 6, 0xde), (0x55, 6, 0xdf), (0x56, 7, 0x1c0), (0x57, 7, 0x1c1),
    (0x58, 7, 0x1c2), (0x59, 7, 0x1c3), (0x5a, 7, 0x1c4), (0x5b, 7, 0x1c5),
    (0x5c, 7, 0x1c6), (0x5d, 7, 0x1c7), (0x5e, 7, 0x1c8), (0x5f, 7, 0x1c9),
    (0x60, 7, 0x1ca), (0x61, 7, 0x1cb), (0x62, 7, 0x1cc), (0x63, 7, 0x1cd),
    (0x64, 7, 0x1ce), (0x65, 7, 0x1cf), (0x66, 7, 0x1d0), (0x67, 7, 0x1d1),
    (0x68, 7, 0x1d2), (0x69, 7, 0x1d3), (0x6a, 7, 0x1d4), (0x6b, 7, 0x1d5),
    (0x6c, 7, 0x1d6), (0x6d, 7, 0x1d7), (0x6e, 7, 0x1d8), (0x6f, 7, 0x1d9),
    (0x70, 7, 0x1da), (0x71, 7, 0x1db), (0x72, 7, 0x1dc), (0x73, 7, 0x1dd),
    (0x74, 7, 0x1de), (0x75, 7, 0x1df), (0x76, 8, 0x3c0), (0x77, 8, 0x3c1),
    (0x78, 8, 0x3c2), (0x79, 8, 0x3c3), (0x7a, 8, 0x3c4), (0x7b, 8, 0x3c5),
    (0x7c, 8, 0x3c6), (0x7d, 8, 0x3c7), (0x7e, 8, 0x3c8), (0x7f, 8, 0x3c9),
    (0x80, 8, 0x3ca), (0x81, 8, 0x3cb), (0x82, 8, 0x3cc), (0x83, 8, 0x3cd),
    (0x84, 8, 0x3ce), (0x85, 8, 0x3cf), (0x86, 8, 0x3d0), (0x87, 8, 0x3d1),
    (0x88, 8, 0x3d2), (0x89, 8, 0x3d3), (0x8a, 8, 0x3d4), (0x8b, 8, 0x3d5),
    (0x8c, 8, 0x3d6), (0x8d, 8, 0x3d7), (0x8e, 8, 0x3d8), (0x8f, 8, 0x3d9),
    (0x90, 8, 0x3da), (0x91, 8, 0x3db), (0x92, 8, 0x3dc), (0x93, 8, 0x3dd),
    (0x94, 8, 0x3de), (0x95, 8, 0x3df), (0x96, 9, 0x7c0), (0x97, 9, 0x7c1),
    (0x98, 9, 0x7c2), (0x99, 9, 0x7c3), (0x9a, 9, 0x7c4), (0x9b, 9, 0x7c5),
    (0x9c, 9, 0x7c6), (0x9d, 9, 0x7c7), (0x9e, 9, 0x7c8), (0x9f, 9, 0x7c9),
    (0xa0, 9, 0x7ca), (0xa1, 9, 0x7cb), (0xa2, 9, 0x7cc), (0xa3, 9, 0x7cd),
    (0xa4, 9, 0x7ce), (0xa5, 9, 0x7cf), (0xa6, 9, 0x7d0), (0xa7, 9, 0x7d1),
    (0xa8, 9, 0x7d2), (0xa9, 9, 0x7d3), (0xaa, 9, 0x7d4), (0xab, 9, 0x7d5),
    (0xac, 9, 0x7d6), (0xad, 9, 0x7d7), (0xae, 9, 0x7d8), (0xaf, 9, 0x7d9),
    (0xb0, 9, 0x7da), (0xb1, 9, 0x7db), (0xb2, 9, 0x7dc), (0xb3, 9, 0x7dd),
    (0xb4, 9, 0x7de), (0xb5, 9, 0x7df), (0xb6, 10, 0xfc0), (0xb7, 10, 0xfc1),
    (0xb8, 10, 0xfc2), (0xb9, 10, 0xfc3), (0xba, 10, 0xfc4), (0xbb, 10, 0xfc5),
    (0xbc, 10, 0xfc6), (0xbd, 10, 0xfc7), (0xbe, 10, 0xfc8), (0xbf, 10, 0xfc9),
    (0xc0, 10, 0xfca), (0xc1, 10, 0xfcb), (0xc2, 10, 0xfcc), (0xc3, 10, 0xfcd),
    (0xc4, 10, 0xfce), (0xc5, 10, 0xfcf), (0xc6, 10, 0xfd0), (0xc7, 10, 0xfd1),
    (0xc8, 10, 0xfd2), (0xc9, 10, 0xfd3), (0xca, 10, 0xfd4), (0xcb, 10, 0xfd5),
    (0xcc, 10, 0xfd6), (0xcd, 10, 0xfd7), (0xce, 10, 0xfd8), (0xcf, 10, 0xfd9),
    (0xd0, 10, 0xfda), (0xd1, 10, 0xfdb), (0xd2, 10, 0xfdc), (0xd3, 10, 0xfdd),
    (0xd4, 10, 0xfde), (0xd5, 10, 0xfdf), (0xd6, 11, 0x1fc0), (0xd7, 11, 0x1fc1),
    (0xd8, 11, 0x1fc2), (0xd9, 11, 0x1fc3), (0xda, 11, 0x1fc4), (0xdb, 11, 0x1fc5),
    (0xdc, 11, 0x1fc6), (0xdd, 11, 0x1fc7), (0xde, 11, 0x1fc8), (0xdf, 11, 0x1fc9),
    (0xe0, 11, 0x1fca), (0xe1, 11, 0x1fcb), (0xe2, 11, 0x1fcc), (0xe3, 11, 0x1fcd),
    (0xe4, 11, 0x1fce), (0xe5, 11, 0x1fcf), (0xe6, 11, 0x1fd0), (0xe7, 11, 0x1fd1),
    (0xe8, 11, 0x1fd2), (0xe9, 11, 0x1fd3), (0xea, 11, 0x1fd4), (0xeb, 11, 0x1fd5),
    (0xec, 11, 0x1fd6), (0xed, 11, 0x1fd7), (0xee, 11, 0x1fd8), (0xef, 11, 0x1fd9),
    (0xf0, 11, 0x1fda), (0xf1, 11, 0x1fdb), (0xf2, 11, 0x1fdc), (0xf3, 11, 0x1fdd),
    (0xf4, 11, 0x1fde), (0xf5, 11, 0x1fdf), (0xf6, 12, 0x3fc0), (0xf7, 12, 0x3fc1),
    (0xf8, 12, 0x3fc2), (0xf9, 12, 0x3fc3), (0xfa, 12, 0x3fc4), (0xfb, 12, 0x3fc5),
    (0xfc, 12, 0x3fc6), (0xfd, 12, 0x3fc7), (0xfe, 12, 0x3fc8), (0xff, 12, 0x3fc9),
    # EOF marker
    (HUFFMAN_EOF, 12, 0x0000),
]
# fmt: on

# Build tree sorted by code_len ascending
DEFAULT_HUFFMAN_TREE: list[HuffmanEntry] = sorted(
    [HuffmanEntry(v, cl, c) for v, cl, c in _RAW_TREE],
    key=lambda e: (e.code_len, e.code),
)

# huffmanLenIndex[n] = index of first entry with code_len == n, or -1
_max_len = max(e.code_len for e in DEFAULT_HUFFMAN_TREE)
DEFAULT_HUFFMAN_LEN_INDEX: list[int] = [-1] * (_max_len + 1)
for _i, _entry in enumerate(DEFAULT_HUFFMAN_TREE):
    if DEFAULT_HUFFMAN_LEN_INDEX[_entry.code_len] == -1:
        DEFAULT_HUFFMAN_LEN_INDEX[_entry.code_len] = _i


def huffman_decode(
    in_buf: bytes | bytearray | memoryview,
    char_count: int,
    tree: list[HuffmanEntry] = DEFAULT_HUFFMAN_TREE,
    len_index: list[int] = DEFAULT_HUFFMAN_LEN_INDEX,
) -> bytes:
    """Decode Huffman-compressed blackbox data.

    Args:
        in_buf: Compressed input bytes.
        char_count: Expected number of output bytes (from 2-byte pseudo-header).
        tree: Huffman tree (sorted by code_len).
        len_index: Index mapping code_len â†’ first tree entry with that length.

    Returns:
        Decompressed bytes.
    """
    if not isinstance(in_buf, memoryview):
        in_buf = memoryview(in_buf if isinstance(in_buf, (bytes, bytearray)) else bytes(in_buf))
    out: bytearray = bytearray()
    code = 0
    code_len = 0
    test_bit = 0x80
    buf_pos = 0
    buf_len = len(in_buf)

    while buf_pos < buf_len:
        if len(out) == char_count:
            break

        # Consume next bit
        code = (code << 1) & 0xFFFF
        code_len += 1
        if in_buf[buf_pos] & test_bit:
            code |= 0x01
        test_bit >>= 1
        if test_bit == 0:
            test_bit = 0x80
            buf_pos += 1

        # Check if current code matches a leaf node
        if code_len < len(len_index) and len_index[code_len] != -1:
            i = len_index[code_len]
            while i < len(tree) and tree[i].code_len == code_len:
                if tree[i].code == code:
                    value = tree[i].value
                    if value == HUFFMAN_EOF:
                        return bytes(out)
                    out.append(value)
                    code = 0
                    code_len = 0
                    break
                i += 1

    return bytes(out)
